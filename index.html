<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harmonia Arcana</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #f3f4f6; }
        .input-styled { background-color: #374151; border: 1px solid #4b5563; color: #f3f4f6; border-radius: 0.375rem; padding: 0.5rem 0.75rem; font-size: 0.875rem; width: 100%; }
        .input-styled:focus { outline: none; border-color: #4f46e5; box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.5); }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 8px; }
        .dot-gray { background-color: #6b7280; } .dot-green { background-color: #10b981; } .dot-yellow { background-color: #f59e0b; }
        #custom-message-box { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1050; display: none; font-size: 0.875rem; border: 1px solid rgba(255,255,255,0.1); }
        .message-success { background-color: #059669; color: #d1fae5; } .message-error { background-color: #b91c1c; color: #fee2e2; } .message-info { background-color: #1d4ed8; color: #dbeafe; }
        .btn-loading { opacity: 0.6; cursor: not-allowed; }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 pt-8 sm:p-6">

    <div id="custom-message-box"></div>
    <div id="api-key-setup-screen" class="w-full max-w-xl hidden">
        </div>

    <div id="main-app-content" class="w-full max-w-xl hidden">
        <header class="mb-6 text-left">
            </header>
        <main id="main-content">
            </main>
        <footer class="mt-10 text-center">
            <p id="version-display" class="text-xs text-gray-600 mt-2"></p>
        </footer>
    </div>

    <script type="module"> 
        const DEBUG = true;
        const log = (...args) => DEBUG && console.log(...args);
        const logError = (...args) => DEBUG && console.error(...args);

        const SCRIPT_VERSION = "V20250607_1400_SOUND_DESIGNER_AI";
        let recognition, isListening = false, accumulatedTranscript = "", analysisInterval;
        const ANALYSIS_INTERVAL_MS = 10000;
        let activeGameInspiration = "";
        const API_KEY_STORAGE_KEY = 'harmoniaArcanaApiKey';
        let apiKey = localStorage.getItem(API_KEY_STORAGE_KEY);

        // --- Funcions de UI (sense canvis) ---
        function showCustomMessage(message, type = 'info', duration = 3000) { /*...*/ }
        function showUI() { /*...*/ }
        function showScreen(screenId) { /*...*/ }
        function updateStatusDisplay(status, color = 'gray') { /*...*/ }
        function setButtonsLoading(loading, message = "Processant...") { /*...*/ }

        // --- Nou Motor Musical Dinàmic ---
        const musicManager = {
            activeParts: [], activeEffects: [], isPaused: false,
            
            play(recipe) {
                this.stop();
                log(`Reproduint nova recepta de disseny de so:`, recipe);
                try {
                    // Efecte global principal
                    const masterReverb = new Tone.Reverb(recipe.effects?.reverb || { decay: 1.5, wet: 0.2 }).toDestination();
                    this.activeEffects.push(masterReverb);

                    recipe.parts.forEach(part => {
                        // Creem la cadena d'efectes per a aquest instrument
                        const partEffects = (part.effects || []).map(effectData => {
                            if (effectData.type === 'chorus') return new Tone.Chorus(effectData).start();
                            if (effectData.type === 'distortion') return new Tone.Distortion(effectData);
                            return null;
                        }).filter(Boolean);

                        this.activeEffects.push(...partEffects);
                        
                        // Creem el sintetitzador
                        let synth;
                        const synthType = part.synth.type || 'Synth';
                        if (Tone[synthType]) {
                           synth = new Tone[synthType](part.synth);
                        } else {
                           synth = new Tone.Synth(part.synth); // Fallback
                        }

                        // Connectem els nodes: synth -> efectes de part -> reverb global -> sortida
                        if (partEffects.length > 0) {
                            synth.chain(...partEffects, masterReverb);
                        } else {
                            synth.connect(masterReverb);
                        }
                        this.activeEffects.push(synth); // El synth també s'ha de 'disposar'

                        // Creem la part musical
                        const tonePart = new Tone.Part((time, value) => {
                            synth.triggerAttackRelease(value.note, value.duration, time);
                        }, part.sequence).start(0);
                        tonePart.loop = true;
                        tonePart.loopEnd = part.loopDuration || "2m";
                        this.activeParts.push(tonePart);
                    });
                    
                    Tone.Transport.bpm.value = recipe.bpm;
                    Tone.Transport.start();
                    this.isPaused = false;
                    document.getElementById('music-status').textContent = `Reproduint (${recipe.name})`;
                    this.updateToggleButton();
                } catch (error) { logError("Error al musicManager.play:", error); showCustomMessage("Error en la recepta musical. Comprova la consola.", "error"); }
            },
            stop() {
                this.activeParts.forEach(part => part.dispose());
                this.activeEffects.forEach(effect => effect.dispose());
                this.activeParts = []; this.activeEffects = [];
                if (Tone.Transport.state !== 'stopped') Tone.Transport.stop();
                Tone.Transport.cancel();
                this.isPaused = false; 
                const musicStatus = document.getElementById('music-status');
                if(musicStatus) musicStatus.textContent = "Aturada";
                this.updateToggleButton();
            },
            pause() { if (Tone.Transport.state === 'started') { Tone.Transport.pause(); this.isPaused = true; this.updateToggleButton();} },
            resume() { if (Tone.Transport.state === 'paused') { Tone.Transport.start(); this.isPaused = false; this.updateToggleButton();} },
            updateToggleButton() { /*...*/ }
        };

        // --- Nou Prompt per a IA Dissenyadora de So ---
        async function getMusicRecipeFromAI(text, inspiration) {
            setButtonsLoading(true, "Consultant IA...");
            updateStatusDisplay("Consultant IA Dissenyadora...", "yellow");
            const API_ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
            const prompt = `
                Ets Harmonia, una IA dissenyadora de so i compositora per a jocs de rol. La teva tasca és crear una partitura i dissenyar els sons dels instruments virtuals en format JSON. Respon obligatòriament en català i només amb el JSON, sense markdown.

                INSPIRACIÓ ESTILÍSTICA: "${inspiration || 'Fantasia èpica'}"
                ESCENA ACTUAL: "${text}"

                INSTRUCCIONS:
                1. Dissenya entre 2 i 4 instruments virtuals que s'adeqüin a l'estil i a l'escena.
                2. Per a cada instrument, defineix una part musical amb una seqüència de notes. Les parts han de complementar-se (melodia, harmonia, baix, ritme).
                3. La teva resposta JSON ha de tenir:
                   - "name": Un nom en català per a la peça.
                   - "bpm": El tempo (número).
                   - "effects": Un objecte opcional per a efectes globals, ex: {"reverb": {"decay": 2, "wet": 0.4}}.
                   - "parts": Un array d'objectes instrumentals. Cada objecte ha de contenir:
                     - "instrument": Un nom descriptiu (ex: "cordes_inquietants").
                     - "loopDuration": La durada del bucle (ex: "4m").
                     - "synth": Un objecte de configuració per a un sintetitzador de Tone.js. Propietats importants: "type" ('FMSynth', 'AMSynth', 'MonoSynth', 'MembraneSynth'), "volume" (en dB), "oscillator" (amb "type"), "envelope" (amb "attack", "decay", "sustain", "release").
                     - "effects": Un array opcional d'efectes per a aquest instrument, ex: [{"type": "chorus", "frequency": 1.5, "depth": 0.7}].
                     - "sequence": Un array d'events per a Tone.Part (objectes amb "time", "note", "duration").

                Exemple per a una escena de tensió a l'estil 'Blade Runner':
                {"name":"Carrers de Neó i Pluja","bpm":70,"effects":{"reverb":{"decay":4,"wet":0.6}},"parts":[{"instrument":"pad_atmosferic","loopDuration":"8m","synth":{"type":"FMSynth","volume":-18,"harmonicity":1.5,"envelope":{"attack":4,"release":4}},"sequence":[{"time":"0:0","note":"C2","duration":"8m"}]},{"instrument":"melodia_solitaria","loopDuration":"8m","synth":{"type":"Synth","volume":-10,"oscillator":{"type":"sawtooth"},"filter":{"type":"lowpass","frequency":1200},"envelope":{"attack":0.1,"release":1}},"effects":[{"type":"chorus","depth":0.8}],"sequence":[{"time":"0:2","note":"G4","duration":"2n"},{"time":"1:1","note":"F4","duration":"2n"}]}]}
            `;
            
            try {
                const response = await fetch(API_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) });
                if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error.message); }
                const responseData = await response.json();
                let jsonText = responseData.candidates[0].content.parts[0].text;
                log("Resposta rebuda de la IA:", jsonText);
                const match = jsonText.match(/\{[\s\S]*\}/);
                if (!match) throw new Error("La resposta de la IA no conté un objecte JSON vàlid.");
                return JSON.parse(match[0]);
            } catch (error) { logError("Error en la petició a la IA:", error); showCustomMessage(`Error de l'API: ${error.message}`, 'error'); return null; 
            } finally {
                setButtonsLoading(false);
            }
        }
        
        async function setupSpeechRecognition() {
            // ... (Codi complet i correcte)
        }
        function startListening() { /*...*/ }
        function stopListening() { /*...*/ }
        async function processAccumulatedTranscript() { /*...*/ }

        document.addEventListener('DOMContentLoaded', async () => {
            // ... (Codi complet i correcte de tots els listeners)
        });
    </script>
</body>
</html>
